abstract class Animal		//추상 클래스 생성. 예약어 abstract 사용
					//추상 클래스는 추상 메소드를 하나 이상 포함하고 있는 클래스를 의미
					//추상 메소드는 자식 클래스에서 재정의(오버라이딩)해야만 사용할 수 있는 메소드. 내부에 실행 코드가 없다
					//추상 메소드가 포함된 클래스는 객체 변수의 생성자로 사용할 수가 없음. Animal ani = new Animal(); 불가
					//추상 메소드는 메모리 주소가 존재하지 않음(구현 내용이 없기에). 재정의를 통해 내용과 주소가 생겨나(실제로 저장됨) 그 위치를 참조할 수 있게 됨

{
	String a = "is animal";
	abstract void look();	//추상 메소드. 이름과 매개변수, 반환하는 타입 이외에는 아무것도 명시되어 있지 않음. abstract 예약어를 통해 선언
					//추후 자식 클래스에서 재정의해줘야 한다

	void show()		//실행 코드가 있는 일반적인 메소드
	{
		System.out.println("Zoo");
	}
}

class Chicken extends Animal		//추상 클래스를 상속한 클래스
{
	Chicken()
	{
		look();
	}

	void look()			//부모의 추상 메소드 look();을 오버라이딩. 추상메소드는 반드시 재정의해줘야 한다
	{
		System.out.println("Chicken" + a);
	}

	void display()
	{
		System.out.println("two wings");
	}
}

public class Test
{
	public static void main(String[] args)
	{
		Animal a = new Chicken();		//Chicken 클래스의 생성자를 이용하여 Animal 객체를 생성
								//이처럼 자식 클래스를 이용해 부모 클래스의 객체를 생성하는 것을 업캐스팅이라 한다
								//이 과정에서 자식클래스->부모클래스 로의 형 변환이 발생함
								//형 변환이 발생했을 때 부모와 자식 간에 동일한 속성/메소드가 존재한다면 자식 클래스의 속성/메소드로 재정의됨
								//업캐스팅은 자식 클래스의 메소드나 필드를 부모 클래스 타입의 변수로 호출할 수 있게 해주지만, 실제 객체는 여전히 자식 클래스의 인스턴스								
								//변수의 자료형은 부모클래스를 따라가지만, 객체 내부의 속성/메소드는 자식클래스의 것이 사용됨. 다형성

								//참조 변수와 실제 객체의 타입은 일치하지 않을 수도 있다
								//참조 변수 : 객체의 주소값을 가지고 있는(객체를 참조하는) 변수. 이 변수의 타입은 객체가 어떤 클래스의 인스턴스인지 나타냄								//객체 : 메모리(heap 공간)에 존재하는 실물. 객체를 생성할 때 지정된 클래스에 의해 타입이 결정됨
								//Animal a = new Chicken();으로 객체를 생성했을 때, 참조 변수 a의 타입은 Animal이고, 실제 객체의 타입은 Chicken
								//동적 바인딩 : 메소드 호출은 런타임에 결정됨. 어떤 메소드를 호출할지 실제 객체의 타입에 따라 결정되는 것
								//다형성 : 특정 타입의 참조변수가 다양한 클래스의 메소드를 호출할 수 있는 것

								//원래 Animal 객체를 생성하는 것은 불가능(추상 클래스)
								//그러나 형 변환으로 인해 look() 메소드가 Chicken() 메소드에서 재정의되었으므로 객체 변수 생성이 가능해진 것
		a.show();
	}
}