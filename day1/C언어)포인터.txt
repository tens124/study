#include<stbio.h>
main()
{
	int a = 50;		//주기억장치의 어딘가에 a라는 이름을 붙이고, 그곳에 50을 저장
	int *b = &a;	//변수명 앞에 *을 붙여 선언해주면 해당 변수는 포인터 변수가 된다. 주소값을 저장 가능. &변수명을 통해 해당 변수의 주소를 전달할 수 있음. 즉 b에는 a의 주소가 저장된 것
				//int형으로 선언. 해당 포인터 변수가 가리키는 곳에 저장되는 값의 자료형을 입력해줘야 함. a에는 int값이 들어가니 포인터도 int형
	*b = *b + 20;	//포인터 변수 b에 값을 저장하면 해당 값은 주소값이 됨. 포인터 변수 앞에 *을 붙여주면 해당 포인터가 가리키는 장소의 값에 영향을 끼침
				//*b, 즉 b가 가리키는 장소인 a에 20을 더해줌
	printf("%d, %d\n", a, *b);	//*b를 출력하게 되면 70이 출력됨. a를 출력해도 마찬가지. 70 출력
	char *s;		//문자형 변수가 저장된 위치를 기억할 포인터 변수 s를 선언
	s="gilbut";		//s에 직접적으로 gilbut이 저장되는 것은 아님. 주기억장치 어딘가에 gilbut이란 이름의 문자열(배열)이 생성된 후, s에는 그 시작점인 g의 주소가 저장됨

	for(int i = 0;i<6;i+=2)
	{
		printf("%c, ",s[i]);		//s[0]은 g. 여기서부터 세어나가면 됨. 따라서 g, ㅣ, u 순서대로 출력
		printf("%c, ",*(s + i));	//(s+i)가 가리키는 곳의 값을 출력. *(s+0)은 g를 의미한다. *(s+1)은 i
		printf("%s\n",s + i);	//s + i를 그대로 출력. s[i]부터 시작하여 끝까지 출력한다고 생각하면 됨
	}
}


주소      값
s         'g'
s+1      'i'
s+2      'l'
s+3      'b'
s+4      'u'
s+5      't'
s+6      '\0'	//NULL문자. 문자열의 끝부분에 자동으로 삽입되나, 보이지는 않는다
문자 자료형의 크기는 1바이트. 따라서 문자열의 경우 다음 문자의 물리적 메모리 위치(주소)는 1바이트를 더한 값이 됨
문자열의 경우, 해당 문자가 그대로 저장되는 것이 아닌 문자의 아스키 코드 값이 저장된다. 정수로도 출력이 가능한 것


포인터가 어떻게 문자열을 가리키는지를 정리한 도표. 제어문자 s를 통해 출력한다면 문자열이 출력되고, p를 통해 출력한다면 주소값이 그대로 출력됨
printf("%s", s + 2);	제어문자 s에 의해 문자열 출력. s + 2부터 시작하여 문자열을 끝까지 출력. 즉 lbut이 출력되게 됨
printf("%p", (void*)(s + 2));	주소값을 출력하는 법. 주소값을 출력할 때는 제어문자 p를 사용하고, (void*)로 형변환하는 것이 일반적. 주소값은 16진수로 출력됨
(void*) 형변환은 특정 타입의 포인터를 범용 포인터 타입인 void*로 변환하는 것. void*는 타입을 명시하지 않는 포인터 타입이기에, 범용적으로 사용하는 것이 가능. int 등의 자료형이 없는 상태라 생각하면 된다